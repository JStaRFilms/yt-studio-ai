import { GoogleGenAI, Type, Chat, Content } from "@google/genai";
import { ChatMessage } from "./db";

// Per guidelines, initialize with a named apiKey parameter from process.env.
const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

/**
 * Interface for the structured content package returned by the API.
 */
export interface ContentPackage {
    titles: string[];
    description: string;
    tags: string[];
}

/**
 * Interface for the structured project data generated from a chat session.
 */
export interface ProjectData {
    title: string;
    script: string;
}

/**
 * Starts a new, stateful chat session.
 * @param history The unified chat history for the session.
 * @returns A Chat instance.
 */
export const startChatSession = (history?: ChatMessage[]): Chat => {
    return ai.chats.create({
        model: 'gemini-2.5-flash',
        history: history,
        config: {
            systemInstruction: "You are a creative partner and brainstorming assistant for a YouTube content creator. Your goal is to help them brainstorm and outline a video script. Be encouraging, ask clarifying questions, and provide structured ideas like lists and outlines. Keep your responses concise and helpful.",
        },
    });
};

/**
 * Rewrites a given piece of text based on a user's instruction using the Gemini API.
 * @param instruction - The instruction for rewriting (e.g., "make this more engaging").
 * @param textToRewrite - The text to be rewritten.
 * @returns The rewritten text as a string.
 */
export const generateRewrite = async (instruction: string, textToRewrite: string): Promise<string> => {
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: `Instruction: "${instruction}"\n\nText to rewrite:\n"${textToRewrite}"`,
            config: {
                systemInstruction: "You are an expert script editor. Rewrite the provided text based on the user's instruction. Only return the rewritten text, without any introductory phrases, explanations, or markdown formatting.",
            },
        });
        return response.text.trim();
    } catch (error) {
        console.error("Error generating rewrite:", error);
        throw new Error("Failed to generate rewrite. Please check your API key and network connection.");
    }
};

/**
 * Generates an image based on a text prompt using the Gemini API.
 * @param prompt - The text prompt for image generation.
 * @returns A base64 encoded string of the generated JPEG image.
 */
export const generateImage = async (prompt: string): Promise<string> => {
    try {
        const response = await ai.models.generateImages({
            model: 'imagen-4.0-generate-001',
            prompt: prompt,
            config: {
                numberOfImages: 1,
                outputMimeType: 'image/jpeg',
                aspectRatio: '16:9',
            },
        });

        if (response.generatedImages && response.generatedImages.length > 0) {
            return response.generatedImages[0].image.imageBytes;
        } else {
            throw new Error("No image was generated by the API.");
        }
    } catch (error) {
        console.error("Error generating image:", error);
        throw new Error("Failed to generate image. Please check your API key and the prompt.");
    }
};

/**
 * Cleans up a script by removing filler words and redundancies.
 * @param script - The full script to clean up.
 * @returns The cleaned-up script as a string.
 */
export const generateCleanup = async (script: string): Promise<string> => {
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: `Instruction: "Clean up this script. Remove filler words (like 'um', 'uh', 'like'), redundancies, and false starts to improve clarity and pacing for a voiceover."\n\nScript:\n"${script}"`,
            config: {
                systemInstruction: "You are an expert script editor. Rewrite the provided script based on the user's instruction. Only return the rewritten text, without any introductory phrases, explanations, or markdown formatting.",
            },
        });
        return response.text.trim();
    } catch (error) {
        console.error("Error cleaning up script:", error);
        throw new Error("Failed to clean up script.");
    }
};

/**
 * Generates a content package (titles, description, tags) for a video script.
 * @param script - The video script content.
 * @returns An object containing titles, description, and tags.
 */
export const generateContentPackage = async (script: string): Promise<ContentPackage> => {
    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: `Based on the following script, generate a content package for a YouTube video.

Script:
---
${script}
---`,
            config: {
                systemInstruction: "You are a YouTube content strategist. Generate exactly 3 compelling titles, 1 concise and engaging description (including relevant hashtags), and an array of 5-8 relevant tags.",
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        titles: { type: Type.ARRAY, items: { type: Type.STRING }, description: "An array of exactly 3 catchy and relevant video titles." },
                        description: { type: Type.STRING, description: "A concise and engaging video description, max 200 characters, including 3-4 hashtags at the end." },
                        tags: { type: Type.ARRAY, items: { type: Type.STRING }, description: "An array of 5-8 relevant tags for discoverability." }
                    },
                    required: ["titles", "description", "tags"]
                }
            }
        });
        const jsonText = response.text.trim();
        return JSON.parse(jsonText) as ContentPackage;
    } catch (error) {
        console.error("Error generating content package:", error);
        throw new Error("Failed to generate content package.");
    }
};

/**
 * Generates a project title and script from a chat history.
 * @param history The chat history.
 * @returns An object containing the generated title and script.
 */
export const generateScriptFromChat = async (history: Content[]): Promise<ProjectData> => {
    const finalPrompt = "Based on our entire conversation, please generate a project title and a concise, well-structured script outline. Respond in JSON format with two keys: 'title' and 'script'. The 'script' should be only the script text, ready for an editor.";
    const contents: Content[] = [...history, { role: 'user', parts: [{ text: finalPrompt }] }];

    try {
        const response = await ai.models.generateContent({
            model: "gemini-2.5-flash",
            contents: contents,
            config: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: Type.OBJECT,
                    properties: {
                        title: { type: Type.STRING, description: "A compelling, concise title for the video project." },
                        script: { type: Type.STRING, description: "A well-structured script outline or starting script." }
                    },
                    required: ["title", "script"]
                }
            }
        });
        const jsonText = response.text.trim();
        return JSON.parse(jsonText) as ProjectData;
    } catch (error) {
        console.error("Error generating script from chat:", error);
        throw new Error("Failed to generate final script.");
    }
};